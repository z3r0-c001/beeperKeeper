<!DOCTYPE html>
<html>
<head>
    <title>BEEPER KEEPER 10000 V2.0 - Hybrid Streaming Edition</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            background: linear-gradient(135deg, #1e293b 0%, #0f172a 100%);
            color: #f1f5f9;
            padding: 20px;
            min-height: 100vh;
            position: relative;
            overflow-x: hidden;
        }

        /* Scattered chicken background - different sizes and rotations */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0.15;
            z-index: 0;
            pointer-events: none;
            background-image:
                url('/static/images/chicken_of_despair.png'), url('/static/images/chicken_of_despair.png'), url('/static/images/chicken_of_despair.png'), url('/static/images/chicken_of_despair.png'),
                url('/static/images/chicken_of_despair.png'), url('/static/images/chicken_of_despair.png'), url('/static/images/chicken_of_despair.png'), url('/static/images/chicken_of_despair.png'),
                url('/static/images/chicken_of_despair.png'), url('/static/images/chicken_of_despair.png'), url('/static/images/chicken_of_despair.png'), url('/static/images/chicken_of_despair.png'),
                url('/static/images/chicken_of_despair.png'), url('/static/images/chicken_of_despair.png'), url('/static/images/chicken_of_despair.png'), url('/static/images/chicken_of_despair.png'),
                url('/static/images/chicken_of_despair.png'), url('/static/images/chicken_of_despair.png'), url('/static/images/chicken_of_despair.png'), url('/static/images/chicken_of_despair.png');
            background-size:
                80px, 120px, 60px, 100px,
                90px, 70px, 110px, 85px,
                75px, 95px, 65px, 105px,
                88px, 72px, 115px, 68px,
                82px, 98px, 78px, 92px;
            background-position:
                8% 12%, 28% 8%, 52% 15%, 78% 10%,
                15% 32%, 42% 28%, 68% 35%, 88% 30%,
                12% 52%, 38% 48%, 62% 55%, 85% 50%,
                18% 72%, 48% 68%, 72% 75%, 92% 70%,
                25% 88%, 55% 85%, 80% 90%, 95% 88%;
            background-repeat: no-repeat;
        }

        body::after {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0.12;
            z-index: 0;
            pointer-events: none;
            background-image:
                url('/static/images/chicken_of_despair.png'), url('/static/images/chicken_of_despair.png'), url('/static/images/chicken_of_despair.png'), url('/static/images/chicken_of_despair.png'),
                url('/static/images/chicken_of_despair.png'), url('/static/images/chicken_of_despair.png'), url('/static/images/chicken_of_despair.png'), url('/static/images/chicken_of_despair.png'),
                url('/static/images/chicken_of_despair.png'), url('/static/images/chicken_of_despair.png'), url('/static/images/chicken_of_despair.png'), url('/static/images/chicken_of_despair.png'),
                url('/static/images/chicken_of_despair.png'), url('/static/images/chicken_of_despair.png'), url('/static/images/chicken_of_despair.png'), url('/static/images/chicken_of_despair.png');
            background-size:
                110px, 65px, 95px, 85px,
                102px, 78px, 88px, 73px,
                92px, 70px, 108px, 83px,
                76px, 98px, 87px, 105px;
            background-position:
                18% 18%, 45% 12%, 72% 20%, 95% 15%,
                5% 42%, 32% 38%, 58% 45%, 82% 40%,
                22% 62%, 50% 58%, 75% 65%, 98% 60%,
                10% 82%, 40% 78%, 65% 85%, 88% 80%;
            background-repeat: no-repeat;
        }

        .header, .controls, .video-grid, .metrics-grid {
            position: relative;
            z-index: 1;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
        }

        .header-chicken {
            width: 300px;
            height: auto;
            margin-bottom: 2px;
            filter: drop-shadow(0 0 10px rgba(96, 165, 250, 0.3));
        }

        .header h1 {
            font-size: 2.5rem;
            font-weight: 700;
            letter-spacing: 2px;
            color: #60a5fa;
            text-shadow: 0 0 20px rgba(96, 165, 250, 0.5);
            margin-top: 2px;
            margin-bottom: 20px;
        }

        .header-logo {
            width: 480px;
            max-width: 90%;
            height: auto;
            margin-bottom: 10px;
            margin-left: auto;
            margin-right: auto;
            display: block;
            filter: drop-shadow(0 0 10px rgba(96, 165, 250, 0.3));
        }

        footer {
            text-align: center;
            padding: 40px 20px 20px;
            margin-top: 40px;
            border-top: 2px solid rgba(96, 165, 250, 0.2);
            position: relative;
            z-index: 1;
        }

        footer p {
            font-size: 1.1rem;
            color: #cbd5e1;
            margin-bottom: 15px;
            font-weight: 500;
        }

        footer a {
            display: inline-block;
            transition: transform 0.2s;
        }

        footer a:hover {
            transform: scale(1.05);
        }

        footer img {
            width: 100px;
            height: auto;
            filter: drop-shadow(0 0 8px rgba(96, 165, 250, 0.2));
        }

        .controls {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        }

        .btn-primary {
            background: #60a5fa;
            color: #0f172a;
        }

        .btn-primary:hover {
            background: #3b82f6;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(96, 165, 250, 0.4);
        }

        .btn-secondary {
            background: #cbd5e1;
            color: #0f172a;
        }

        .btn-secondary:hover {
            background: #94a3b8;
            transform: translateY(-2px);
        }

        .btn.active {
            background: #10b981;
            color: white;
        }

        .video-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        .video-grid.dual {
            grid-template-columns: 1fr 1fr;
        }

        .video-container {
            background: #000;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 4px 16px rgba(0,0,0,0.4);
            border: 2px solid #14b8a6;
            position: relative;
        }

        .video-container.hidden {
            display: none;
        }

        .video-label {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(15, 23, 42, 0.8);
            padding: 5px 12px;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 600;
            color: #60a5fa;
            z-index: 10;
        }

        video {
            width: 100%;
            height: 500px;
            display: block;
            background: #000;
        }

        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 20px;
        }

        /* Responsive grid: 4 cards ‚Üí 2x2 ‚Üí 1 column */
        @media (max-width: 1200px) {
            .metrics-grid {
                grid-template-columns: repeat(2, 1fr);
            }
        }

        @media (max-width: 768px) {
            .metrics-grid {
                grid-template-columns: 1fr;
            }
        }

        .card {
            background: rgba(255,255,255,0.05);
            backdrop-filter: blur(10px);
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 4px 16px rgba(0,0,0,0.3);
            border: 2px solid #14b8a6;
        }

        .card h2 {
            font-size: 1.2rem;
            margin-bottom: 15px;
            color: #60a5fa;
            font-weight: 600;
        }

        .metric {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }

        .metric:last-child {
            border-bottom: none;
        }

        .metric-label {
            color: #cbd5e1;
            font-size: 14px;
        }

        .metric-value {
            color: #f1f5f9;
            font-weight: 600;
            font-size: 14px;
        }

        .status-good { color: #10b981; }
        .status-warn { color: #f59e0b; }
        .status-error { color: #ef4444; }

        /* Water level progress bar */
        .water-level-bar {
            width: 100%;
            height: 30px;
            background: rgba(255,255,255,0.1);
            border-radius: 8px;
            overflow: hidden;
            margin: 10px 0;
            border: 1px solid #14b8a6;
        }

        .water-level-fill {
            height: 100%;
            background: linear-gradient(90deg, #14b8a6 0%, #10b981 100%);
            transition: width 0.5s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: 600;
            font-size: 14px;
        }

        .water-level-fill.low {
            background: linear-gradient(90deg, #ef4444 0%, #dc2626 100%);
        }

        .water-level-fill.medium {
            background: linear-gradient(90deg, #f59e0b 0%, #eab308 100%);
        }

        @media (max-width: 1024px) {
            .video-grid.dual {
                grid-template-columns: 1fr;
            }
        }

        /* Mobile optimizations for logo and header */
        @media (max-width: 768px) {
            .header-logo {
                width: 100%;
                max-width: 360px;
                padding: 0 15px;
            }

            .header h1 {
                font-size: 1.8rem;
            }
        }

        @media (max-width: 480px) {
            .header-logo {
                max-width: 280px;
            }

            .header h1 {
                font-size: 1.5rem;
            }
        }

        /* Countdown Timer Styles */
        .countdown-container {
            position: relative;
            z-index: 1;
            max-width: 600px;
            margin: 0 auto 25px;
        }

        .countdown-card {
            background: rgba(255,255,255,0.05);
            backdrop-filter: blur(10px);
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 4px 16px rgba(0,0,0,0.3);
            border: 2px solid #14b8a6;
            transition: all 0.3s ease;
        }

        .countdown-card.phase-day {
            border-color: #fb923c;
            background: rgba(251, 146, 60, 0.08);
        }

        .countdown-card.phase-night {
            border-color: #60a5fa;
            background: rgba(96, 165, 250, 0.08);
        }

        .countdown-label {
            font-size: 1.1rem;
            font-weight: 700;
            text-align: center;
            margin-bottom: 15px;
            letter-spacing: 1px;
        }

        .countdown-card.phase-day .countdown-label {
            color: #fb923c;
        }

        .countdown-card.phase-night .countdown-label {
            color: #60a5fa;
        }

        .countdown-display {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-bottom: 15px;
        }

        .countdown-unit {
            text-align: center;
        }

        .countdown-number {
            font-size: 2.5rem;
            font-weight: 700;
            line-height: 1;
            margin-bottom: 5px;
        }

        .countdown-card.phase-day .countdown-number {
            color: #fb923c;
        }

        .countdown-card.phase-night .countdown-number {
            color: #60a5fa;
        }

        .countdown-text {
            font-size: 0.8rem;
            color: #cbd5e1;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .countdown-progress-container {
            width: 100%;
            height: 8px;
            background: rgba(255,255,255,0.1);
            border-radius: 4px;
            overflow: hidden;
            margin-top: 15px;
        }

        .countdown-progress-bar {
            height: 100%;
            transition: width 1s linear;
            border-radius: 4px;
        }

        .countdown-card.phase-day .countdown-progress-bar {
            background: linear-gradient(90deg, #fb923c 0%, #f97316 100%);
        }

        .countdown-card.phase-night .countdown-progress-bar {
            background: linear-gradient(90deg, #60a5fa 0%, #3b82f6 100%);
        }

        .countdown-target {
            text-align: center;
            font-size: 0.9rem;
            color: #cbd5e1;
            margin-top: 10px;
        }

        /* Email Alert Subscription Form */
        .alert-subscription {
            margin-top: 20px;
            padding-top: 15px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        .alert-subscription h3 {
            font-size: 0.95rem;
            color: #60a5fa;
            margin-bottom: 12px;
            text-align: center;
            font-weight: 600;
        }

        .alert-form {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .alert-form input[type="email"] {
            width: 100%;
            padding: 10px 12px;
            border: 2px solid #14b8a6;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.05);
            color: #f1f5f9;
            font-size: 0.9rem;
            transition: border-color 0.2s;
        }

        .alert-form input[type="email"]:focus {
            outline: none;
            border-color: #60a5fa;
            background: rgba(255, 255, 255, 0.08);
        }

        .alert-form input[type="email"]::placeholder {
            color: #64748b;
        }

        .checkbox-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .checkbox-label {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.85rem;
            color: #cbd5e1;
            cursor: pointer;
            padding: 6px;
            border-radius: 6px;
            transition: background 0.2s;
        }

        .checkbox-label:hover {
            background: rgba(255, 255, 255, 0.05);
        }

        .checkbox-label input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
            accent-color: #14b8a6;
        }

        .alert-form button {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            font-size: 0.9rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            margin-top: 5px;
        }

        .btn-subscribe {
            background: #14b8a6;
            color: white;
        }

        .btn-subscribe:hover {
            background: #0d9488;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(20, 184, 166, 0.4);
        }

        .btn-subscribe:disabled {
            background: #64748b;
            cursor: not-allowed;
            transform: none;
        }


        .alert-message {
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 0.85rem;
            text-align: center;
            margin-top: 8px;
        }

        .alert-message.success {
            background: rgba(16, 185, 129, 0.2);
            color: #10b981;
            border: 1px solid #10b981;
        }

        .alert-message.error {
            background: rgba(239, 68, 68, 0.2);
            color: #ef4444;
            border: 1px solid #ef4444;
        }

        @media (max-width: 480px) {
            .countdown-display {
                gap: 10px;
            }

            .countdown-number {
                font-size: 2rem;
            }

            .countdown-label {
                font-size: 0.95rem;
            }

            .alert-subscription h3 {
                font-size: 0.85rem;
            }

            .checkbox-label {
                font-size: 0.8rem;
            }
        }

        /* Chat Section Layout - Full Width with Who's Viewing Sidebar */
        .chat-section-wrapper {
            display: flex;
            gap: 20px;
            width: 100%;
            margin: 20px auto;
            position: relative;
            z-index: 1;
            align-items: stretch;
        }

        .chat-container {
            flex: 1;
            min-width: 0;
            display: flex;
            flex-direction: column;
        }

        .chat-container .card {
            height: 100%;
            display: flex;
            flex-direction: column;
        }

        .whos-viewing {
            width: 300px;
            flex-shrink: 0;
        }

        .whos-viewing .card {
            height: 100%;
        }

        /* Responsive: Stack on smaller screens */
        @media (max-width: 1024px) {
            .chat-section-wrapper {
                flex-direction: column;
            }

            .whos-viewing {
                width: 100%;
            }
        }

        /* Autoplay Blocked Overlay - appears if browser blocks video autoplay */
        .autoplay-blocked-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(15, 23, 42, 0.95);
            z-index: 9999;
            display: none;
            justify-content: center;
            align-items: center;
        }

        .autoplay-blocked-overlay.visible {
            display: flex;
        }

        .autoplay-blocked-btn {
            background: linear-gradient(135deg, #60a5fa 0%, #3b82f6 100%);
            color: white;
            border: 3px solid #60a5fa;
            border-radius: 16px;
            padding: 30px 60px;
            font-size: 1.5rem;
            font-weight: 700;
            cursor: pointer;
            box-shadow: 0 12px 32px rgba(96, 165, 250, 0.6);
            transition: all 0.2s ease;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
            animation: pulse 2s infinite;
        }

        .autoplay-blocked-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 16px 40px rgba(96, 165, 250, 0.8);
        }

        .autoplay-blocked-btn:active {
            transform: scale(0.98);
        }

        @media (max-width: 480px) {
            .autoplay-blocked-btn {
                font-size: 1.2rem;
                padding: 20px 40px;
            }
        }

    </style>
</head>
<body>
    <!-- Autoplay Blocked Overlay (shown only if browser blocks autoplay) -->
    <div class="autoplay-blocked-overlay" id="autoplayBlockedOverlay">
        <button class="autoplay-blocked-btn" onclick="startStreamsWithUserGesture()">
            <span style="font-size: 3rem;">‚ñ∂Ô∏è</span>
            <span>Tap to Start Streams</span>
            <span style="font-size: 0.9rem; opacity: 0.8;">Your browser requires a tap to play video</span>
        </button>
    </div>

    <div class="header">
        <img src="/static/images/beeperKeeper.png" alt="Beeper Keeper 10000" class="header-logo">
    </div>

    <!-- Countdown Timer -->
    <div class="countdown-container">
        <div id="countdownCard" class="countdown-card phase-day">
            <div id="countdownLabel" class="countdown-label">
                <span id="countdownEmoji">üåô</span> COUNTDOWN TO LIGHTS OUT
            </div>
            <div class="countdown-display">
                <div class="countdown-unit">
                    <div id="countdownHours" class="countdown-number">--</div>
                    <div class="countdown-text">Hours</div>
                </div>
                <div class="countdown-unit">
                    <div id="countdownMinutes" class="countdown-number">--</div>
                    <div class="countdown-text">Minutes</div>
                </div>
                <div class="countdown-unit">
                    <div id="countdownSeconds" class="countdown-number">--</div>
                    <div class="countdown-text">Seconds</div>
                </div>
            </div>
            <div class="countdown-progress-container">
                <div id="countdownProgressBar" class="countdown-progress-bar" style="width: 0%"></div>
            </div>
            <div id="countdownTarget" class="countdown-target">Target: 7:00 PM</div>

            <!-- Email Alert Subscription Form -->
            <div class="alert-subscription">
                <h3>Get Email Alerts</h3>
                <form class="alert-form" id="alertSubscriptionForm" onsubmit="handleAlertSubscription(event)">
                    <input
                        type="email"
                        id="alertEmail"
                        placeholder="Enter your email address"
                        required
                    >
                    <div class="checkbox-group">
                        <label class="checkbox-label">
                            <input type="checkbox" id="alertLightsOn" name="alert_on">
                            <span>Alert 15 min before lights ON (6:15 AM)</span>
                        </label>
                        <label class="checkbox-label">
                            <input type="checkbox" id="alertLightsOff" name="alert_off">
                            <span>Alert 15 min before lights OFF (6:45 PM)</span>
                        </label>
                    </div>
                    <button type="submit" class="btn-subscribe" id="subscribeBtn">
                        Subscribe to Alerts
                    </button>
                    <div id="alertMessage" class="alert-message" style="display: none;"></div>
                </form>
            </div>
        </div>
    </div>

    <div class="controls">
        <button class="btn btn-primary active" onclick="setView('dual')">Dual View</button>
        <button class="btn btn-secondary" onclick="setView('csi')">IR Camera Only</button>
        <button class="btn btn-secondary" onclick="setView('usb')">USB Camera Only</button>
    </div>

    <div class="video-grid dual" id="videoGrid">
        <div class="video-container" id="csiContainer">
            <div class="video-label">IR CAMERA (CSI)</div>
            <video id="csiVideo" controls autoplay playsinline muted></video>
        </div>
        <div class="video-container" id="usbContainer">
            <div class="video-label">USB WEBCAM (with audio)</div>
            <video id="usbVideo" controls autoplay playsinline muted></video>
        </div>
    </div>

    <!-- Chat Section with Who's Viewing Sidebar -->
    <div class="chat-section-wrapper">
        <div class="chat-container">
            <div class="card">
                <h2>Chat</h2>
                <div id="chatMessages" style="height: 200px; overflow-y: auto; border: 1px solid #14b8a6; border-radius: 8px; padding: 10px; margin-bottom: 10px; background: #0f172a;"></div>
                <div style="display: flex; gap: 10px;">
                    <input type="text" id="chatInput" placeholder="Type a message..." style="flex: 1; padding: 10px; border: 1px solid #14b8a6; border-radius: 8px; background: #1e293b; color: #f1f5f9; font-family: inherit;" maxlength="500">
                    <button onclick="sendChatMessage()" style="padding: 10px 20px; background: #14b8a6; color: white; border: none; border-radius: 8px; cursor: pointer; font-family: inherit;">Send</button>
                </div>
            </div>
        </div>
        <div class="whos-viewing">
            <div class="card">
                <h2>Who's Viewing</h2>
                <div id="whoViewing">Loading...</div>
            </div>
        </div>
    </div>

    <div class="metrics-grid">
        <div class="card">
            <h2>System Health</h2>
            <div id="systemHealth">Loading...</div>
        </div>

        <div class="card">
            <h2>Camera Sensor</h2>
            <div id="cameraSensor">Loading...</div>
        </div>

        <div class="card">
            <h2>Environmental Sensors</h2>
            <div id="envSensors">Loading...</div>
        </div>

        <div class="card">
            <h2>Water Tank</h2>
            <div id="waterTank">Loading...</div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
    <script>
        // ============================================
        // BEEPER KEEPER v2.0 - HYBRID STREAMING EDITION
        // Version: 2024-11-06-HYBRID
        // CSI: WebRTC (ultra low latency, video only)
        // USB: HLS (better audio sync, lower CPU)
        // ============================================
        console.log('[BeeperKeeper] Loading v2.0-HYBRID (2024-11-06)');

        let currentView = 'dual';
        const HLS_BASE = '{{ hls_base }}';
        const WEBRTC_BASE = '{{ webrtc_base }}';
        let autoplayBlocked = false; // Track if autoplay was blocked
        let streamsInitialized = false; // Track if streams were initialized

        // Detect if we're on Cloudflare tunnel or local network
        const isCloudflare = window.location.hostname.includes('YOUR_WEBSITE') ||
                            window.location.hostname.includes('cloudflare');
        const useWebRTC = !isCloudflare && (window.location.hostname === '10.10.10.28' ||
                                           window.location.hostname === 'localhost');

        // Mobile detection
        function isMobileDevice() {
            return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) ||
                   (navigator.maxTouchPoints && navigator.maxTouchPoints > 2);
        }

        // Start streams with user gesture (fallback for blocked autoplay)
        async function startStreamsWithUserGesture() {
            console.log('User gesture received, starting streams...');

            const csiVideo = document.getElementById('csiVideo');
            const usbVideo = document.getElementById('usbVideo');

            try {
                // Try to play both videos
                await Promise.all([
                    csiVideo.play(),
                    usbVideo.play()
                ]);

                console.log('Streams started successfully after user gesture');

                // Auto-unmute USB video after user gesture (has audio)
                usbVideo.muted = false;
                console.log('‚úì USB video auto-unmuted after user gesture (audio enabled)');

                // CSI camera has no audio, keep muted
                csiVideo.muted = true;
                console.log('‚úì CSI video stays muted (no audio track)');

                // Hide the overlay
                document.getElementById('autoplayBlockedOverlay').classList.remove('visible');
                autoplayBlocked = false;

            } catch (error) {
                console.error('Failed to start streams even with user gesture:', error);
                // Keep overlay visible and show error
                alert('Unable to start video streams. Please refresh the page and try again.');
            }
        }


        // Initialize streams based on access method
        async function initStreams() {
            if (useWebRTC) {
                console.log('Using WebRTC (ultra low latency <2s)');
                try {
                    await initWebRTC();
                } catch (e) {
                    console.error('WebRTC failed, falling back to HLS:', e);
                    initHLS();
                }
            } else {
                console.log('Using HLS (Cloudflare tunnel compatible, ~5-10s latency)');
                initHLS();
            }
        }

        // Initialize HLS streams (fallback for Cloudflare)
        function initHLS() {
            const csiVideo = document.getElementById('csiVideo');
            const usbVideo = document.getElementById('usbVideo');

            if (Hls.isSupported()) {
                // Detect mobile for optimized HLS config
                const isMobile = isMobileDevice();

                // Mobile-optimized HLS configuration
                // Mobile: Reduced buffers, no low-latency mode, longer timeouts
                // Desktop: Standard config for better performance
                const hlsConfig = {
                    enableWorker: true,
                    lowLatencyMode: !isMobile,           // Disable on mobile (less overhead)
                    backBufferLength: isMobile ? 1 : 3,  // Less buffering on mobile (save memory)
                    maxBufferLength: isMobile ? 3 : 5,
                    maxMaxBufferLength: isMobile ? 5 : 8,
                    maxBufferHole: 0.5,
                    maxFragLookUpTolerance: 0.25,
                    liveSyncDurationCount: isMobile ? 2 : 3,
                    liveMaxLatencyDurationCount: isMobile ? 3 : 5,
                    liveBackBufferLength: 0,
                    debug: false,
                    xhrSetup: function(xhr, url) {
                        xhr.withCredentials = true;
                        xhr.setRequestHeader('CF-Access-Client-Id', 'cb5a20abf');
                        xhr.setRequestHeader('CF-Access-Client-Secret', 'a9244fcf740620e7838607af43b46149b0f042f052211a11ee85fce719e9710fca77fa17572d1a329b3ef59.access');
                        xhr.timeout = isMobile ? 15000 : 10000;  // Longer timeout on mobile (cellular latency)
                    }
                };

                console.log('HLS config:', isMobile ? 'Mobile-optimized' : 'Desktop');
                const csiHls = new Hls(hlsConfig);
                csiHls.loadSource(HLS_BASE + '/csi_camera/index.m3u8');
                csiHls.attachMedia(csiVideo);

                // Explicitly play after media is attached (ensures autoplay on mobile)
                csiHls.on(Hls.Events.MANIFEST_PARSED, () => {
                    csiVideo.play().catch(err => {
                        console.log('CSI autoplay prevented:', err);
                        // Show overlay if autoplay is blocked
                        if (err.name === 'NotAllowedError') {
                            autoplayBlocked = true;
                            document.getElementById('autoplayBlockedOverlay').classList.add('visible');
                        }
                    });
                });

                // Log HLS.js errors
                csiHls.on(Hls.Events.ERROR, (event, data) => {
                    console.error('CSI HLS Error:', data);
                });

                // USB camera uses same mobile-optimized config + audio auto-load
                const usbHlsConfig = {...hlsConfig, autoStartLoad: true};  // Ensure audio track loads automatically
                const usbHls = new Hls(usbHlsConfig);
                usbHls.loadSource(HLS_BASE + '/usb_camera/index.m3u8');
                usbHls.attachMedia(usbVideo);

                // Debug: Log audio tracks when available
                usbHls.on(Hls.Events.AUDIO_TRACKS_UPDATED, (event, data) => {
                    console.log('USB Camera Audio Tracks:', data.audioTracks);
                    if (data.audioTracks && data.audioTracks.length > 0) {
                        console.log('‚úì Audio track detected:', data.audioTracks[0]);
                    } else {
                        console.warn('‚ö† No audio tracks found in manifest');
                    }
                });

                // Explicitly play after media is attached (ensures autoplay on mobile)
                usbHls.on(Hls.Events.MANIFEST_PARSED, () => {
                    console.log('USB manifest parsed, attempting play...');

                    usbVideo.play().then(() => {
                        console.log('‚úì USB video playing');
                        // Try to unmute after successful play
                        setTimeout(() => {
                            usbVideo.muted = false;
                            console.log('‚úì USB video unmuted (audio should play)');
                        }, 500);
                    }).catch(err => {
                        console.log('USB autoplay prevented:', err);
                        // Show overlay if autoplay is blocked
                        if (err.name === 'NotAllowedError') {
                            autoplayBlocked = true;
                            document.getElementById('autoplayBlockedOverlay').classList.add('visible');
                        }
                    });
                });

                // Log HLS.js errors
                usbHls.on(Hls.Events.ERROR, (event, data) => {
                    console.error('USB HLS Error:', data);
                    if (data.details === Hls.ErrorDetails.AUDIO_TRACK_LOAD_ERROR) {
                        console.error('‚ö† Audio track failed to load!');
                    }
                });

                console.log('‚úì HLS streams initialized');
            } else if (csiVideo.canPlayType('application/vnd.apple.mpegurl')) {
                csiVideo.src = HLS_BASE + '/csi_camera/index.m3u8';
                usbVideo.src = HLS_BASE + '/usb_camera/index.m3u8';
                console.log('‚úì Native HLS supported');
            }
        }

        // Initialize WebRTC streams (local network only)
        async function initWebRTC() {
            await startWebRTC('csiVideo', WEBRTC_BASE + '/csi_camera/whep', false);  // CSI: video only
            await startWebRTC('usbVideo', WEBRTC_BASE + '/usb_camera/whep', true);   // USB: video + audio (enabled)
            console.log('‚úì WebRTC streams initialized');
        }

        async function startWebRTC(videoElementId, whepUrl, hasAudio = true) {
            const video = document.getElementById(videoElementId);
            const pc = new RTCPeerConnection({
                iceServers: [],
                bundlePolicy: 'max-bundle'
            });

            pc.ontrack = (event) => {
                // CRITICAL: Set muted BEFORE assigning srcObject to pass browser autoplay policy check
                video.muted = true;
                video.srcObject = event.streams[0];
                video.play().catch(e => {
                    console.log('WebRTC autoplay prevented:', e);
                    // Show overlay if autoplay is blocked
                    if (e.name === 'NotAllowedError') {
                        autoplayBlocked = true;
                        document.getElementById('autoplayBlockedOverlay').classList.add('visible');
                    }
                });
            };

            pc.addTransceiver('video', { direction: 'recvonly' });
            if (hasAudio) {
                pc.addTransceiver('audio', { direction: 'recvonly' });
            }

            const offer = await pc.createOffer();
            await pc.setLocalDescription(offer);

            const response = await fetch(whepUrl, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/sdp'
                },
                body: offer.sdp
            });

            if (response.status === 201) {
                const answer = await response.text();
                await pc.setRemoteDescription(new RTCSessionDescription({
                    type: 'answer',
                    sdp: answer
                }));
                console.log(`‚úì ${videoElementId} WebRTC connected`);
            } else {
                throw new Error(`WHEP connection failed: ${response.status}`);
            }
        }

        function setView(view) {
            currentView = view;
            const videoGrid = document.getElementById('videoGrid');
            const csiContainer = document.getElementById('csiContainer');
            const usbContainer = document.getElementById('usbContainer');

            // Update button states
            document.querySelectorAll('.controls .btn').forEach(btn => {
                btn.className = 'btn btn-secondary';
            });

            if (view === 'dual') {
                videoGrid.className = 'video-grid dual';
                csiContainer.className = 'video-container';
                usbContainer.className = 'video-container';
                event.target.className = 'btn btn-primary active';
            } else if (view === 'csi') {
                videoGrid.className = 'video-grid';
                csiContainer.className = 'video-container';
                usbContainer.className = 'video-container hidden';
                event.target.className = 'btn btn-primary active';
            } else if (view === 'usb') {
                videoGrid.className = 'video-grid';
                csiContainer.className = 'video-container hidden';
                usbContainer.className = 'video-container';
                event.target.className = 'btn btn-primary active';
            }
        }

        // User activity tracking
        let userState = 'viewing';

        // Send heartbeat every 30 seconds
        function sendHeartbeat() {
            fetch('/api/heartbeat', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ state: userState })
            }).catch(err => console.log('Heartbeat failed:', err));
        }

        // Track tab visibility
        document.addEventListener('visibilitychange', () => {
            userState = document.hidden ? 'away' : 'viewing';
            sendHeartbeat(); // Send immediate update on state change
        });

        // Send goodbye on page close
        window.addEventListener('beforeunload', () => {
            navigator.sendBeacon('/api/user_left');
        });

        // Update active users list
        function updateActiveUsers() {
            fetch('/api/active_users')
                .then(response => response.json())
                .then(data => {
                    const users = data.users || [];

                    if (users.length === 0) {
                        document.getElementById('whoViewing').innerHTML = `
                            <div class="metric status-warn">No active viewers</div>
                        `;
                        return;
                    }

                    const viewing = users.filter(u => u.state === 'viewing');
                    const away = users.filter(u => u.state === 'away');

                    let html = '';

                    if (viewing.length > 0) {
                        html += `<div class="metric"><span class="metric-label">üëÅÔ∏è Viewing (${viewing.length})</span></div>`;
                        viewing.forEach(u => {
                            html += `<div class="metric"><span class="metric-value" style="padding-left: 20px;">‚Ä¢ ${u.username}</span></div>`;
                        });
                    }

                    if (away.length > 0) {
                        html += `<div class="metric" style="margin-top: 10px;"><span class="metric-label">üí§ Away (${away.length})</span></div>`;
                        away.forEach(u => {
                            const timeAgo = u.last_seen_seconds < 60 ?
                                `${u.last_seen_seconds}s ago` :
                                `${Math.floor(u.last_seen_seconds / 60)}m ago`;
                            html += `<div class="metric"><span class="metric-value" style="padding-left: 20px;">‚Ä¢ ${u.username} (${timeAgo})</span></div>`;
                        });
                    }

                    document.getElementById('whoViewing').innerHTML = html;
                })
                .catch(error => console.error('Error fetching active users:', error));
        }

        // Chat functions
        function sendChatMessage() {
            const input = document.getElementById('chatInput');
            const message = input.value.trim();

            if (!message) return;

            fetch('/api/chat/send', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ message: message })
            })
            .then(response => response.json())
            .then(data => {
                if (data.status === 'ok') {
                    input.value = '';
                    updateChatMessages(); // Immediately fetch new messages
                }
            })
            .catch(error => console.error('Error sending message:', error));
        }

        function updateChatMessages() {
            fetch('/api/chat/messages')
                .then(response => response.json())
                .then(data => {
                    const messagesDiv = document.getElementById('chatMessages');
                    const messages = data.messages || [];

                    if (messages.length === 0) {
                        messagesDiv.innerHTML = '<div style="color: #64748b; text-align: center; padding: 20px;">No messages yet. Start the conversation!</div>';
                        return;
                    }

                    let html = '';
                    messages.forEach(msg => {
                        const date = new Date(msg.timestamp * 1000);
                        const timeStr = date.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' });
                        const currentUser = getCurrentUsername();
                        const canDelete = msg.id && (msg.username === currentUser);
                        const deleteBtn = canDelete ? `<button onclick="deleteChatMessage('${msg.id}')" style="background: #dc2626; color: white; border: none; border-radius: 4px; padding: 2px 8px; font-size: 0.75em; margin-left: 8px; cursor: pointer;" title="Delete message">üóëÔ∏è</button>` : '';
                        
                        html += `
                            <div style="margin-bottom: 8px;">
                                <span style="color: #3b82f6; font-weight: bold;">${msg.username}</span>
                                <span style="color: #64748b; font-size: 0.85em; margin-left: 8px;">${timeStr}</span>
                                ${deleteBtn}
                                <div style="color: #f1f5f9; margin-left: 20px;">${escapeHtml(msg.message)}</div>
                            </div>
                        `;
                    });

                    messagesDiv.innerHTML = html;
                    // Auto-scroll to bottom
                    messagesDiv.scrollTop = messagesDiv.scrollHeight;
                })
                .catch(error => console.error('Error fetching messages:', error));
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function getCurrentUsername() {
            // Extract username from Cloudflare Access JWT header (if available)
            // For local development, this will fall back to a default username
            try {
                const jwtHeader = document.cookie.split('; ').find(row => row.startsWith('CF_Authorization='));
                if (jwtHeader) {
                    const token = jwtHeader.split('=')[1];
                    const payload = JSON.parse(atob(token.split('.')[1]));
                    return payload.email ? payload.email.split('@')[0] : 'local-user';
                }
            } catch (e) {
                console.log('No JWT found, using fallback username');
            }
            // Fallback: use a simple identifier
            return 'local-' + window.location.hostname;
        }

        function deleteChatMessage(messageId) {
            if (!confirm('Delete this message?')) {
                return;
            }

            fetch(`/api/chat/delete/${messageId}`, {
                method: 'DELETE',
                headers: {
                    'Content-Type': 'application/json'
                }
            })
            .then(response => {
                if (response.ok) {
                    // Refresh messages
                    updateChatMessages();
                } else {
                    return response.json().then(data => {
                        alert('Error: ' + (data.error || 'Could not delete message'));
                    });
                }
            })
            .catch(error => {
                console.error('Error deleting message:', error);
                alert('Error deleting message');
            });
        }

        // Allow Enter key to send message
        document.addEventListener('DOMContentLoaded', () => {
            const chatInput = document.getElementById('chatInput');
            if (chatInput) {
                chatInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        sendChatMessage();
                    }
                });
            }
        });

        function updateMetrics() {
            fetch('/api/metrics')
                .then(response => response.json())
                .then(data => {
                    // System Health (combined with System Stats)
                    const cpu_temp = data.cpu_temperature || 0;
                    const temp_class = cpu_temp > 70 ? 'status-error' : (cpu_temp > 60 ? 'status-warn' : 'status-good');

                    const sys = data.system || {};
                    const cpu_class = sys.cpu_percent > 85 ? 'status-error' : (sys.cpu_percent > 70 ? 'status-warn' : 'status-good');
                    const mem_class = sys.memory_percent > 85 ? 'status-error' : (sys.memory_percent > 70 ? 'status-warn' : 'status-good');

                    const uptime_hours = Math.floor(sys.uptime_seconds / 3600);
                    const uptime_mins = Math.floor((sys.uptime_seconds % 3600) / 60);

                    document.getElementById('systemHealth').innerHTML = `
                        <div class="metric">
                            <span class="metric-label">CPU Temperature</span>
                            <span class="metric-value ${temp_class}">${cpu_temp.toFixed(1)}¬∞C</span>
                        </div>
                        <div class="metric">
                            <span class="metric-label">CPU Usage</span>
                            <span class="metric-value ${cpu_class}">${sys.cpu_percent}%</span>
                        </div>
                        <div class="metric">
                            <span class="metric-label">Memory Usage</span>
                            <span class="metric-value ${mem_class}">${sys.memory_percent}%</span>
                        </div>
                        <div class="metric">
                            <span class="metric-label">Disk Usage</span>
                            <span class="metric-value">${sys.disk_percent}%</span>
                        </div>
                        <div class="metric">
                            <span class="metric-label">Uptime</span>
                            <span class="metric-value">${uptime_hours}h ${uptime_mins}m</span>
                        </div>
                    `;

                    // Camera Sensor
                    const cam = data.camera || {};
                    let cameraHtml = '';
                    if (Object.keys(cam).length === 0) {
                        cameraHtml = '<div class="metric status-warn">No metadata available</div>';
                    } else {
                        cameraHtml = `
                            <div class="metric">
                                <span class="metric-label">Exposure Time</span>
                                <span class="metric-value">${cam.exposure_time}¬µs</span>
                            </div>
                            <div class="metric">
                                <span class="metric-label">Analogue Gain</span>
                                <span class="metric-value">${cam.analogue_gain}x</span>
                            </div>
                            <div class="metric">
                                <span class="metric-label">Lux</span>
                                <span class="metric-value">${cam.lux !== null ? cam.lux : 'N/A'}</span>
                            </div>
                            <div class="metric">
                                <span class="metric-label">Color Temp</span>
                                <span class="metric-value">${cam.colour_temp || 'N/A'}K</span>
                            </div>
                        `;
                    }
                    document.getElementById('cameraSensor').innerHTML = cameraHtml;

                    // Environmental Sensors
                    const env = data.i2c_sensors?.bme680 || {};
                    let envHtml = '';
                    if (Object.keys(env).length === 0) {
                        envHtml = '<div class="metric status-warn">No sensor data</div>';
                    } else {
                        let iaq_class = 'status-good';
                        if (env.iaq !== null && env.iaq !== undefined) {
                            if (env.iaq > 250) iaq_class = 'status-error';
                            else if (env.iaq > 150) iaq_class = 'status-warn';
                        }

                        envHtml = `
                            <div class="metric">
                                <span class="metric-label">Temperature</span>
                                <span class="metric-value">${env.temperature}¬∞C</span>
                            </div>
                            <div class="metric">
                                <span class="metric-label">Humidity</span>
                                <span class="metric-value">${env.humidity}%</span>
                            </div>
                            <div class="metric">
                                <span class="metric-label">Pressure</span>
                                <span class="metric-value">${env.pressure} hPa</span>
                            </div>
                        `;

                        if (env.calibration_status === 'calibrating') {
                            const progress = env.calibration_progress || 0;
                            envHtml += `
                                <div class="metric">
                                    <span class="metric-label">IAQ Status</span>
                                    <span class="metric-value status-warn">Calibrating ${progress}%</span>
                                </div>
                                <div class="metric">
                                    <span class="metric-label">Gas (Raw)</span>
                                    <span class="metric-value">${env.gas_raw} Œ©</span>
                                </div>
                            `;
                        } else {
                            envHtml += `
                                <div class="metric">
                                    <span class="metric-label">Air Quality (IAQ)</span>
                                    <span class="metric-value ${iaq_class}">${env.iaq !== null ? env.iaq : 'N/A'}</span>
                                </div>
                                <div class="metric">
                                    <span class="metric-label">IAQ Level</span>
                                    <span class="metric-value ${iaq_class}">${env.iaq_classification}</span>
                                </div>
                                <div class="metric">
                                    <span class="metric-label">CO‚ÇÇ Equiv.</span>
                                    <span class="metric-value">${env.co2_equivalent !== null ? env.co2_equivalent + ' ppm' : 'N/A'}</span>
                                </div>
                                <div class="metric">
                                    <span class="metric-label">Gas (Raw)</span>
                                    <span class="metric-value">${env.gas_raw} Œ©</span>
                                </div>
                            `;
                        }

                        // Add audio level with color-coded thresholds
                        const audio_db = data.audio_level || 0;
                        let db_class = 'status-good';
                        if (audio_db >= 85) {
                            db_class = 'status-error';  // Red: Very loud
                        } else if (audio_db >= 70) {
                            db_class = 'status-warn';   // Yellow/Orange: Loud
                        } else if (audio_db >= 50) {
                            db_class = 'status-warn';   // Yellow: Elevated
                        }
                        // else: Green (normal/quiet) - default

                        envHtml += `
                            <div class="metric">
                                <span class="metric-label">dB Level</span>
                                <span class="metric-value ${db_class}">${audio_db.toFixed(1)} dB</span>
                            </div>
                        `;
                    }
                    document.getElementById('envSensors').innerHTML = envHtml;

                    // Water Tank
                    const water = data.water || {};
                    let waterHtml = '';
                    if (Object.keys(water).length === 0 || !water.percent_full) {
                        waterHtml = '<div class="metric status-warn">No water data</div>';
                    } else {
                        const percent = water.percent_full || 0;
                        const status = water.status || 'unknown';

                        // Determine status class and bar class
                        let status_class = 'status-good';
                        let bar_class = '';
                        if (status === 'error' || status === 'offline') {
                            status_class = 'status-error';
                        } else if (percent < 20) {
                            bar_class = 'low';
                            status_class = 'status-error';
                        } else if (percent < 50) {
                            bar_class = 'medium';
                            status_class = 'status-warn';
                        }

                        waterHtml = `
                            <div class="water-level-bar">
                                <div class="water-level-fill ${bar_class}" style="width: ${percent}%">
                                    ${percent.toFixed(1)}%
                                </div>
                            </div>
                            <div class="metric">
                                <span class="metric-label">Water Level</span>
                                <span class="metric-value">${water.water_level_cm || 0} cm</span>
                            </div>
                            <div class="metric">
                                <span class="metric-label">Distance</span>
                                <span class="metric-value">${water.distance_cm || 0} cm</span>
                            </div>
                            <div class="metric">
                                <span class="metric-label">Tank Height</span>
                                <span class="metric-value">${water.tank_height_cm || 0} cm</span>
                            </div>
                            <div class="metric">
                                <span class="metric-label">Sensor Status</span>
                                <span class="metric-value ${status_class}">${status}</span>
                            </div>
                        `;
                    }
                    document.getElementById('waterTank').innerHTML = waterHtml;
                })
                .catch(error => console.error('Error fetching metrics:', error));
        }

        // Countdown Timer
        function updateCountdown() {
            fetch('/api/lights_countdown')
                .then(response => response.json())
                .then(data => {
                    if (data.error) {
                        console.error('Countdown API error:', data.error);
                        return;
                    }

                    // Update numbers
                    document.getElementById('countdownHours').textContent = String(data.hours).padStart(2, '0');
                    document.getElementById('countdownMinutes').textContent = String(data.minutes).padStart(2, '0');
                    document.getElementById('countdownSeconds').textContent = String(data.seconds).padStart(2, '0');

                    // Update label and emoji
                    document.getElementById('countdownEmoji').textContent = data.emoji;
                    document.getElementById('countdownLabel').innerHTML =
                        `<span id="countdownEmoji">${data.emoji}</span> ${data.label}`;

                    // Update phase (day/night) styling
                    const card = document.getElementById('countdownCard');
                    card.classList.remove('phase-day', 'phase-night');
                    card.classList.add(`phase-${data.phase}`);

                    // Update progress bar
                    document.getElementById('countdownProgressBar').style.width = `${data.progress}%`;

                    // Update target time
                    document.getElementById('countdownTarget').textContent = `Target: ${data.target_time}`;
                })
                .catch(error => console.error('Error fetching countdown:', error));
        }

        // Email Alert Subscription Functions
        function showAlertMessage(message, isSuccess) {
            const alertMsg = document.getElementById('alertMessage');
            alertMsg.textContent = message;
            alertMsg.className = `alert-message ${isSuccess ? 'success' : 'error'}`;
            alertMsg.style.display = 'block';

            // Hide message after 5 seconds
            setTimeout(() => {
                alertMsg.style.display = 'none';
            }, 5000);
        }

        function handleAlertSubscription(event) {
            event.preventDefault();

            const email = document.getElementById('alertEmail').value.trim();
            const alertOn = document.getElementById('alertLightsOn').checked;
            const alertOff = document.getElementById('alertLightsOff').checked;
            const subscribeBtn = document.getElementById('subscribeBtn');

            // Validate at least one checkbox is selected
            if (!alertOn && !alertOff) {
                showAlertMessage('Please select at least one alert type', false);
                return;
            }

            // Disable button during submission
            subscribeBtn.disabled = true;
            subscribeBtn.textContent = 'Subscribing...';

            fetch('/api/lights/alerts/subscribe', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    email: email,
                    alert_on: alertOn,
                    alert_off: alertOff
                })
            })
            .then(response => response.json())
            .then(data => {
                if (data.status === 'success') {
                    showAlertMessage('Thanks', true);

                    // Temporarily change button appearance, then reset (NO disabling)
                    subscribeBtn.textContent = 'Subscribed ‚úì';
                    subscribeBtn.style.background = '#10b981'; // Green color

                    // Reset button after 3 seconds - form stays editable
                    setTimeout(() => {
                        subscribeBtn.textContent = 'Subscribe to Alerts';
                        subscribeBtn.style.background = ''; // Reset to default
                    }, 3000);

                    // Re-enable button (in case it was disabled during submission)
                    subscribeBtn.disabled = false;
                } else {
                    showAlertMessage(data.error || 'Failed to subscribe', false);
                    // Re-enable button only on error
                    subscribeBtn.disabled = false;
                    subscribeBtn.textContent = 'Subscribe to Alerts';
                }
            })
            .catch(error => {
                console.error('Subscription error:', error);
                showAlertMessage('Network error. Please try again.', false);
                // Re-enable button only on error
                subscribeBtn.disabled = false;
                subscribeBtn.textContent = 'Subscribe to Alerts';
            });
        }


        // Initialize on load
        window.addEventListener('load', () => {
            initStreams();
            updateMetrics();
            updateActiveUsers();
            updateChatMessages();
            updateCountdown();

            // Update metrics every 2 seconds
            setInterval(updateMetrics, 2000);

            // Send heartbeat every 30 seconds
            sendHeartbeat(); // Send initial heartbeat
            setInterval(sendHeartbeat, 30000);

            // Update active users every 30 seconds
            setInterval(updateActiveUsers, 30000);

            // Update chat messages every 3 seconds
            setInterval(updateChatMessages, 3000);

            // Update countdown every second
            setInterval(updateCountdown, 1000);
        });
    </script>

    <footer>
        <p>Brought to you by the good folks at Good Supply Farm</p>
        <div style="display: flex; gap: 30px; justify-content: center; align-items: center;">
            <a href="https://YOUR_WEBSITE" target="_blank">
                <img src="/static/images/tinyWaxer.png" alt="Good Supply Farm">
            </a>
            <div style="width: 1px; height: 80px; background: gold;"></div>
            <a href="https://chickenmatrix.work" target="_blank">
                <img src="/static/images/chicken_of_despair.png" alt="Chicken Matrix" style="width: 100px; height: auto;">
            </a>
        </div>
    </footer>
</body>
</html>
